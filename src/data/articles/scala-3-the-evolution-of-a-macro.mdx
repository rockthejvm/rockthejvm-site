---
author: daniel-beskin
category: guide
difficulty: advanced
excerpt: Discover how a macro can evolve to reduce boilerplate in your code
publishedDate: 2025-04-10
repositoryUrl: https://github.com/ncreep/scala3-macro-tracing-blog
tags: [fp, scala, scala-3, macros]
title: "Scala 3: The Evolution of a Macro"
---
## Introduction

In this post we are going to explore how Scala 3's macros can be used to simplify the use of a semi-realistic and boilerplaty tracing library.
We'll see how we can reduce boilerplate using different levels of macro implementations, starting from simple but minimally helpful, and evolving our macros into something more complex but almost magical.

Each step in this evolution will use various macro capabilities and we'll see how to leverage them to reduce boilerplate in our code.

## Disclaimer

This post is long, going through a lot of code. Please take your time reading it, and let each part sink in before moving on.

Throughout the code examples basic understanding of Scala 3's macro APIs is assumed. Things like quotes/splices, `Expr`, `Tree`, `Symbol`, etc., should be familiar to the reader. You can think of this blog as a supplement to Rock the JVM's [metaprogramming course](/courses/scala-macros-and-metaprogramming). For an in-depth introduction to macros you can read [this](scala-3-macros-comprehensive-guide) article.

## Setup

All the code from the post is available in <a href={frontmatter.repositoryUrl}>this</a> repo. The project is set up using sbt. If you want to follow along in a REPL, please use the project's sbt console:
```
sbt console
```

This will set up the imports required for code snippets to work.

You can use:
```
sbt run
```
To choose any of the runnable examples in the code.

The project uses a couple compilation flags:
- `-Xprint:postInlining` - prints out the code that the compiler generated after expanding macros, this is useful for macro inspection/debugging, and can be turned off if the output is too noisy (disabled in the console)
- `-experimental` - enables all of Scala's experimental features without requiring the `@experimental` annotation

The code samples below assume the presence of some helper classes, mostly related to the fictional tracing library.
The full code can be found in the <a href={frontmatter.repositoryUrl}>repo</a>, we won't be showing it in detail here.

Due to how macros work, defining and using macros must happen in separate files. If you're running code in the REPL you'll need to write the code for the macro, evaluate it, and only then try to use it.

With the setup out of the way, we are ready to dive in. But first, let's take a look at a baseline implementation without macros, so that we can see what kind of code we want to automate.

##  Baseline

Our goal is to trace a block of code with some metadata that is provided by the user. That is, we want to surround a call to the block of code with informative calls to the tracing library. Here's our baseline implementation:

```scala wrap=false
import scala.util.control.NonFatal

object Baseline:
  def trace0[A](level: TraceLevel, // 1
                id: => String, // 2
                fields: => (String, String)*) // 3
               (body: => A) // 4
               (using tracer: Tracer): A = // 5

    if tracer.isLevelEnabled(level) then // 6
      tracer.start(level, id, fields*) // 7

      try // 8
        val result = body // 9
        tracer.finish(level, id, "result" -> result.toString) // 10

        result // 11
      catch
        case NonFatal(e) => // 12
          tracer.finish(level, id, "exception" -> e.toString) // 13

          throw e // 14
    else body // 15
```

Let's break this down:

- We receive as arguments:
  - A tracing level, we'll only trace when that level is enabled (1)
  - An ID that identifies the code being traced we pass things with by-name parameters so that we don't actually evaluate them unless tracing is enabled (2)
  - Metadata fields to be added the tracing call, meant to serve as a list of key/value entries (3)
  - The actual code being traced, again by-name, as we want to suspend its evaluation to inject tracing before/after it runs (4)
  - A tracer, to be filled in by the compiler so as to not bother the users of the tracing library (5)
- In the implementation itself:
  - We first check whether tracing is enabled for the current level (6)
  - Only then we invoke our tracing call with all the metadata (7)
  - We wrap everything with a `try` so as to be able to catch failures and signal them to the tracer (8)
  - We run the body (9)
  - If we finished successfully, we notify the tracer and add the result as metadata[^avoidToString] (10)
  - And we return the result to the caller (11)
  - If anything goes wrong, we catch all non-fatal exceptions (12)
  - And notify the tracer[^againToString]  (13)
  - And re-throw the exception back to the caller (14)
  - If tracing is disabled we run the body without any instrumentation (15)

[^avoidToString]: This is for illustration purposes only, using `toString` like this is probably not what you want in a generic context.
[^againToString]: Again, `toString` for illustration only.

And here's a usage example exercising this code:

```scala wrap=false
class ClassToBeTraced0:
  import Baseline.*

  // 1
  private given tracer: Tracer = Tracer.make[ClassToBeTraced0]

  // 2
  def theMethodToBeTraced(arg1: String,
                          arg2: Int,
                          arg3: SomeData,
                          arg4: UntraceableData): String =
    trace0(
      level = TraceLevel.Info,
      id = "theMethodToBeTraced", // 3
      "arg1" -> arg1.toString,
      "arg2" -> arg2.toString,
      "arg3" -> arg3.toString,
      "arg4" -> arg4.toString):

        if arg2 > 2 then "hello" // 4
        else "bye"
```

In this example:
- We initialize a given tracer (1)
- `theMethodToBeTraced` is the method that we actually want to be traced (2)
- To trace the invocation of this method we'll use the method name as the ID and add all the arguments we got as metadata (3)
- And then we pass in the actual body of the method (4).

This code works, but one concern about it is that it might lose on performance as we are wrapping arguments in by-name parameters. Using `trace0` might be slower than writing the `if/else` manually every time.

Ideally we would want to avoid the `if/else` boilerplate but also avoid the performance cost. Of course you might not care about performance in this context, and then this code is perfectly fine, but imagine that this is a generic library code and you want your users to be able to use it "for free".

Let's see how we can improve on this.

## With Inlining

Scala 3 has a builtin way to avoid the performance cost incurred by using by-name arguments: `inline`s.
You can read more about them [here](scala-3-inlines).

Marking all the arguments as `inline` makes our tracing function zero-cost, we no longer have to wrap our arguments in any function wrappers. We mark the whole method as inline so as to completely remove any overhead to calling `trace1`.

```scala wrap=false
object WithInlining:
  inline def trace1[A](level: TraceLevel,
                       inline id: String, // 1
                       inline fields: (String, String)*)
                      (inline body: A) // 2
                      (using tracer: Tracer): A =
    // 3
    if tracer.isLevelEnabled(level) then
      tracer.start(level, id, fields*)
      try
        val result = body
        tracer.finish(level, id, "result" -> result.toString)
        result
      catch
        case NonFatal(e) =>
          tracer.finish(level, id, "exception" -> e.toString)
          throw e
    else body
```

- Note how instead of `=>` we now use `inline` (1)
- The `body` is now also `inline`, it will be invoked as is, without the by-name indirection (2)
- The implementation is the same as before, as the syntax for using by-name arguments and inlines is the same (3)

Now we can try actually calling `trace1` and inspect the compiler generated code:
```scala wrap=false
class ClassToBeTraced1:
  import WithInlining.*

  private given tracer: Tracer = Tracer.make[ClassToBeTraced1]

  def theMethodToBeTraced(arg1: String,
                          arg2: Int,
                          arg3: SomeData,
                          arg4: UntraceableData): String =
    // 1
    trace1(
      level = TraceLevel.Info,
      id = "theMethodToBeTraced",
      "arg1" -> arg1.toString,
      "arg2" -> arg2.toString,
      "arg3" -> arg3.toString,
      "arg4" -> arg4.toString):
      if arg2 > 2 then "hello"
      else "bye"
```
This code looks exactly like before. The only difference being apparent if we inspect the compiler generated code, we can see that the `trace1` call disappears completely and the code looks pretty much the same as if someone wrote a manual `if/else` block (1).

Since generated code is a bit noisy, we hide it below.

<details>
<summary>Click here to see the generated code</summary>

```scala wrap=false
def theMethodToBeTraced(arg1: String, arg2: Int, arg3: SomeData, arg4: UntraceableData): String =
  (if this.tracer.isLevelEnabled(TraceLevel.Info) then
    {
      this.tracer.start(TraceLevel.Info,
        "theMethodToBeTraced",
        [ArrowAssoc[String]("arg1").->[String](arg1.toString()),
          ArrowAssoc[String]("arg2").->[String](arg2.toString()),
          ArrowAssoc[String]("arg3").->[String](arg3.toString()),
          ArrowAssoc[String]("arg4").->[String](arg4.toString()) :
          (String, String)]**
      )
      try
        {
          val result: String = if arg2.>(2) then "hello" else "bye" // <--- 1
          this.tracer.finish(TraceLevel.Info,
            "theMethodToBeTraced",
            [ArrowAssoc[String]("result").->[String](result.toString()) :
              (String, String)]*
          )
          result:String
        }
       catch
        {
          case scala.util.control.NonFatal(e @ _) =>
            this.tracer.finish(TraceLevel.Info,
              "theMethodToBeTraced",
              [ArrowAssoc[String]("exception").->[String](e.toString()) :
                (String, String)]*
            )
            throw e
        }
    }
   else if arg2.>(2) then "hello" else "bye"):String // <--- 2
```

Ignoring the noise, we can see that there are no closures generated in (1) and (2), just a plain `if/else` block.
</details>

This pretty much solves any performance issues we had with by-name parameters. On the other hand, this usage pattern of tracing a method call with its name and arguments seems very repetitive, and error-prone. I even had a naming error while refactoring the code.

It would be annoying if users had to write this out all on their own every time. We can try to remove this boilerplate, unfortunately, `inline` can't really help us here, as it doesn't have any access to argument names. For this we'll have to resort to macros.

## A Basic Macro

First, we'll reimplement the logic from `trace1` using a macro. This serves as a reminder for macro syntax, but is not actually necessary, as the result is the same thing as `trace1`, we don't add any more magic at the moment.

```scala wrap=false
import scala.quoted.*

object BasicMacro:
  // 1
  inline def trace2[A](level: TraceLevel,
                       inline id: String,
                       inline fields: (String, String)*)
                      (inline body: A)
                      (using tracer: Tracer): A =
    // 2
    ${ trace2Impl('level, 'id, 'fields, 'body, 'tracer) }

  // 3
  def trace2Impl[A: Type](level: Expr[TraceLevel],
                          id: Expr[String],
                          fields: Expr[Seq[(String, String)]],
                          body: Expr[A],
                          tracer: Expr[Tracer])
                         (using Quotes): Expr[A] =
    // 4
    '{
      if $tracer.isLevelEnabled($level) then
        $tracer.start($level, $id, $fields*)
        try
          val result = $body
          $tracer.finish($level, $id, "result" -> result.toString)
          result
        catch
          case NonFatal(e) =>
            $tracer.finish($level, $id, "exception" -> e.toString)
            throw e
      else $body
    }
```

Ignoring the special macro syntax, this code is very similar to the previous example:
- We define an inline function with the same signature as before (1)
- Then proceed to invoke the macro implementation with all the arguments quoted (2)
- Note that we must provide the `Type` constraint here, since we are using a type parameter (3)
- The implementation itself is the same code as in `trace1` but now it's all in quotes and splices (4)

The final generated code from this implementation will be the same as in the `inline` version.

Important: without inlining, the arguments to `trace2` will be evaluated before the macro code is [evaluated](https://docs.scala-lang.org/scala3/guides/macros/inline.html#semantics-of-inline-methods). This differs from how it works in Scala 2. So even though we don't intend to inspect the `Expr`s for the arguments, we still need to mark them as `inline` even when the method is actually a macro.

The usage of the macro is the same as `trace1` except we are forced to define it in a separate file (an implementation limitation of macros). We won't repeat the code here, but you can see it in the <a href={`${frontmatter.repositoryUrl}/blob/master/src/main/scala/ncreep/tracing/02b.BasicMacroUsage.scala`}>repo</a>.

Congratulations, we just dipped our toes into a macro, but we didn't actually improve anything. Let's make the first step in that direction.

## No Method Name

The first step in reducing boilerplate when tracing methods: we are going to automatically compute the ID from the name of the method that invoked the `trace` method[^topLevel]. This will be the first macro that does something "interesting" which cannot be achieved with inlines.

[^topLevel]: For this series of examples we assume that tracing is going to be invoked at the top-level of a method, and will, in effect, be the tracing of the whole method. If this is not actually the case, the result from running this macro might turn out to be gibberish (like having the generated ID be the name of some synthetic method created by the compiler). Adapting the macro for more flexible behavior is left as an exercise to...

The information about the method where tracing is invoked is readily available to the compiler and can be exposed within the macro using the (compile-time) reflection API. Namely, we will use `Symbol.spliceOwner` to access the information about the code that invoked the macro[^naming].

[^naming]: The word `splice` in `spliceOwner` refers to the fact that macros are written as top-level splices (as in quoting and splicing).

We do have to be careful, when invoking a macro the compiler creates a synthetic `Symbol` which is the owner of the macro invocation. This is not what we want for the tracing ID. Luckily, the "real" invoker of the macro (in our case the enclosing method) is the owner of the synthetic symbol. And so we obtain the real owner by climbing up one level from the `spliceOwner` result[^moreRobust].

[^moreRobust]: A more robust macro might recursively go up until reaching an enclosing method. Instead we just skip one level up and check that the result is indeed a method. This is risky as nothing guarantees that the complier won't insert more synthetic symbols in the future.

Let's define `trace3` to be the same as `trace2` but now we no longer have to specify the name of the enclosing method being invoked, so we omit the `id` argument. Like so:
```scala wrap=false
object NoMethodName:
  // 1
  inline def trace3[A](level: TraceLevel, inline fields: (String, String)*)
                      (inline body: A)
                      (using tracer: Tracer): A =
    ${ trace3Impl('level, 'fields, 'body, 'tracer) } // 2

  def trace3Impl[A: Type](level: Expr[TraceLevel],
                          fields: Expr[Seq[(String, String)]],
                          body: Expr[A],
                          tracer: Expr[Tracer])
                         (using Quotes): Expr[A] =
    import quotes.reflect.* // 3

    val methodName = Symbol.spliceOwner.owner match // 4
      case methodSymbol if methodSymbol.isDefDef => // 5
        methodSymbol.name // 6
      case _ => report.errorAndAbort("`trace` can only be used inside a method") // 7

    val id = Expr(methodName) // 8

    '{ WithInlining.trace1($level, $id, $fields*)($body)(using $tracer) } // 9
```

This new macro looks quite different compared to what we had before:
- The signature of `trace3` is the same as `trace2` but without the `id` argument (1)
- Now we invoke the macro implementation, note how we no longer have an ID argument (2)
- Since we are going to use some compile-time reflection to obtain the name of the enclosing method, we need the magic `reflect` import[^whyMagic] (3)
- `Symbol.spliceOwner` lets us obtain the symbol that invoked this macro (4); as noted above, we must be careful to actually use the owner's owner[^ownerOwner].
- We want to make sure that the enclosing symbol is a method definition (5), as we will only support tracing from methods in this macro
- We obtain the  name of the method being traced (6), which we'll use as the ID below
- If somehow the owner is not a method[^notAMethod] we abort with a custom error (7)
- We can now convert into an `Expr` to be spliced in the resulting code (8)
- To avoid duplication, we are just going to invoke `trace1` again, except that we pre-populate the `id` argument with the name of the method (9)

[^whyMagic]: It's magic because it's path-dependently typed. It relies on the given `Quotes` instance that we have in scope.
[^ownerOwner]: Paraphrasing the famous question: "who owns the owners?"
[^notAMethod]: E.g., the compiler changes the implementation details of macro invocations, or the macro call is not inside a method

We can use this as follows:
```scala wrap=false
class NoMethodNameUsage:
  import NoMethodName.*

  private given tracer: Tracer = Tracer.make[NoMethodNameUsage]

  def theMethodToBeTraced(arg1: String,
                          arg2: Int,
                          arg3: SomeData,
                          arg4: UntraceableData): String =
    trace3( // 1
      TraceLevel.Info,
      "arg1" -> arg1.toString,
      "arg2" -> arg2.toString,
      "arg3" -> arg3.toString,
      "arg4" -> arg4.toString):
      if arg2 > 2 then "hello"
      else "bye"
```

This is the same as the usage example before, but we no longer pass in the method name (1). We can see in the generated code how it's filled in.

<details>
<summary>Click here to see the generated code</summary>

```scala wrap=false
def theMethodToBeTraced(arg1: String, arg2: Int, arg3: SomeData, arg4: UntraceableData): String =
    (if this.tracer.isLevelEnabled(TraceLevel.Info) then
      {
        this.tracer.start(TraceLevel.Info,
          "theMethodToBeTraced",
          [ArrowAssoc[String]("arg1").->[String](arg1.toString()),
            ArrowAssoc[String]("arg2").->[String](arg2.toString()),
            ArrowAssoc[String]("arg3").->[String](arg3.toString()),
            ArrowAssoc[String]("arg4").->[String](arg4.toString()) :
            (String, String)]***
        )
        try
          {
            val result: String = if arg2.>(2) then "hello" else "bye"
            this.tracer.finish(TraceLevel.Info,
              "theMethodToBeTraced", // <--- 1
              [ArrowAssoc[String]("result").->[String](result.toString()) :
                (String, String)]*
            )
            result:String
          }
         catch 
          {
            case scala.util.control.NonFatal(e @ _) =>
              this.tracer.finish(TraceLevel.Info,
                "theMethodToBeTraced",
                [ArrowAssoc[String]("exception").->[String](e.toString()) :
                  (String, String)]*
              )
              throw e
          }
      }
     else if arg2.>(2) then "hello" else "bye"):String:String
}
```
As can be seen in (1), the method name is auto-generated for us without it being explicitly written in user code.
</details>

Conversely, the code below won't compile, as it is not invoked within a method and so the `isDefDef` check will fail with our custom error.

```scala wrap=false
val theValToBeTraced: String =
  trace3( TraceLevel.Info):
    if 3 > 2 then "hello"
    else "bye"
```

Like so:
```txt wrap=false
[error] -- Error: 03b.NoMethodNameUsage.scala:22:4
[error] 22 |    trace3( TraceLevel.Info):
[error]    |    ^
[error]    |    `trace` can only be used inside a method
[error] 23 |      if 3 > 2 then "hello"
[error] 24 |      else "bye"
[error] one error found
[error] (Compile / compileIncremental) Compilation failed
```

The call above is an improvement, but we can do better. Passing in all the method arguments with their names can also be automated by the macro.

## No Field Names

In this new variation we'll have the same functionality as `trace3` but now we will no longer have to repetitively name the arguments on our own or convert them to strings. We'll just pick up the names of the `val`s that are passed to the tracing method.

For example:
```scala wrap=false
trace4(TraceLevel.Info, arg1, arg2, arg3)
```

Will be equivalent to:
```scala wrap=false
trace3(
  TraceLevel.Info,
  "arg1" -> arg1.toString,
  "arg2" -> arg2.toString,
  "arg3" -> arg3.toString)
```

Since this transformation is completely mechanical, and uses information that is available at compile-time, this is a good fit for some macro automation.

The stars of this section are going to be `Varargs` and `Expr.ofSeq`. These let us flip `Seq` and `Expr` layers: `Expr[Seq[Any]] <=> Seq[Expr[Any]]`[^sequence]. Where the left side is how the compiler represents varargs passed into the macro, and the right side are a bunch of `Expr`s that we can inspect individually. Once we extracted the argument names that are no longer provided by the user from each `Expr`, and created the list of `argName -> argValue` expressions, we flip the layers back to be passed along as varargs down the line.

[^sequence]: Similar to the `sequence` function from functional programming.

To wit:
```scala wrap=false
object NoFieldNames:

  inline def trace4[A](level: TraceLevel, inline fieldValues: Any*) // 1
                      (inline body: A)
                      (using tracer: Tracer): A =
    ${ trace4Impl('level, 'fieldValues, 'body, 'tracer) }

  def trace4Impl[A: Type](level: Expr[TraceLevel],
                          fieldValues: Expr[Seq[Any]],
                          body: Expr[A],
                          tracer: Expr[Tracer])
                         (using Quotes): Expr[A] =
    import quotes.reflect.*

    // 2
    val varargExpressions: Seq[Expr[Any]] = fieldValues match
      case Varargs(argExprs) => argExprs // 3
      case _ => // 4
        report.errorAndAbort("`fieldValues` must be varargs")

    val fieldsWithNames = varargExpressions.map: arg => // 5
      arg.asTerm match // 6
        case Ident(name) => // 7
          val fieldName = Expr(name)

          '{ $fieldName -> $arg.toString } // 8
        case _ => report.errorAndAbort("field names must be simple identifiers") // 9

    val fields: Expr[Seq[(String, String)]] = Expr.ofSeq(fieldsWithNames) // 10

    NoMethodName.trace3Impl(level, fields, body, tracer) // 11
```

Things are starting to get serious, let's break it down:
- The signature is the same as `trace3` but instead of passing key/value pairs for the fields, we now pass a single vararg with only the `Any` field values (1)
- We mark the vararg argument as `inline` so that we can inspect its contents and extract the field names
- The first order of business is to extract each expression that was passed as a vararg into a separate `Expr` instance
- We use the custom `Varargs` extractor to flip the `Expr` and `Seq` layers (2)
- The result is now a list of `Expr`s (3)
- We do some error handling in case `Varargs` fails to match, which probably can never happen, but we can't prove it to the compiler (4)
- Now we want to find the name of each argument we got and pair it with that argument (5)
- We convert to a `Term` so that we can match on the argument and extract its name (6)
- For the purposes of the example we only support simple identifiers as names as arguments
- Given an identifier we match on it and take its name as a string (7)[^complexArgs]
- We now create a quoted tuple, where we splice the name of the identifier along with the value we are going to pass into tracing (8)
- Note how this recreates the logic we manually had to write for each field when calling `trace3`
- In case we got anything that's not a simple identifier, we abort compilation (9)
- We can now use `Expr.ofSeq` to go back to an `Expr[Seq[...]]`, again, note the layer flip (10)
- Finally, the fully baked `Expr` for the fields can be passed along as a vararg to the implementation of `trace3` macro (11)
- This way we don't have to rewrite the method name extraction logic but we pre-populate the fields with the ones we extracted from the varargs 

[^complexArgs]: It's conceivable to support more complicated arguments as well but that would open the question of how to name them in the tracing output.

Using the macro now just got much simpler:
```scala wrap=false
class NoFieldNamesUsage:
  import NoFieldNames.*

  private given tracer: Tracer = Tracer.make[NoFieldNamesUsage]

  def theMethodToBeTraced(arg1: String,
                          arg2: Int,
                          arg3: SomeData,
                          arg4: UntraceableData): String =
    // 1
    trace4(TraceLevel.Info, arg1, arg2, arg3, arg4):
      if arg2 > 2 then "hello"
      else "bye"
```

We can use tracing just as we did before (1), but now we no longer have to manually repeat the argument names, they are extracted automatically from the names of the values we passed in (and we still automatically extract the enclosing method name as an ID). We can see this happening in the generated

<details>
<summary>Click here to see the generated code</summary>

```scala wrap=false
def theMethodToBeTraced(arg1: String,
                         arg2: Int,
                         arg3: SomeData,
                         arg4: UntraceableData)
                         : String =
  (if this.tracer.isLevelEnabled(TraceLevel.Info) then
    {
      this.tracer.start(TraceLevel.Info,
        "theMethodToBeTraced",
        [ArrowAssoc[String]("arg1").->[String](arg1.toString()), // <--- 1
          ArrowAssoc[String]("arg2").->[String](arg2.toString()),
          ArrowAssoc[String]("arg3").->[String](arg3.toString()),
          ArrowAssoc[String]("arg4").->[String](arg4.toString()) :
          (String, String)]**
      )
      try 
        {
          val result: String = if arg2.>(2) then "hello" else "bye"
          this.tracer.finish(TraceLevel.Info,
            "theMethodToBeTraced",
            [ArrowAssoc[String]("result").->[String](result.toString()) :
              (String, String)]*
          )
          result:String
        }
      catch 
        {
          case scala.util.control.NonFatal(e @ _) =>
            this.tracer.finish(TraceLevel.Info,
              "theMethodToBeTraced",
              [ArrowAssoc[String]("exception").->[String](e.toString()) :
                (String, String)]*
            )
            throw e
        }
    }
  else if arg2.>(2) then "hello" else "bye"):String:String
}
```

Both method name and field names are inserted automatically (1).

</details>

But we have to be careful to pass in only simple identifiers. This won't compile because the varargs we passed in are not made up of simple identifiers:
```scala wrap=false
def theMethodToBeTraced2(arg1: String,
                         arg2: Int,
                         arg3: SomeData,
                         arg4: UntraceableData): String =
  trace4(TraceLevel.Info, arg1, arg2 * 2, arg3, arg4): // 1
    if arg2 > 2 then "hello"
    else "bye"
```

(1) will fail like so:
```txt wrap=false
[error] -- Error: 04b.NoFieldNamesUsage.scala:18:4
[error] 18 |    trace4(TraceLevel.Info, arg1, arg2 * 2, arg3, arg4):
[error]    |    ^
[error]    |    field names must be simple identifiers
[error] 19 |      if arg2 > 2 then "hello"
[error] 20 |      else "bye"
[error] one error found
[error] (Compile / compileIncremental) Compilation failed
```

We can still do better. The usage pattern we have here is to take all the method's arguments and just pass them along. Instead of repeating the method arguments manually, we can pick them up directly from the macro, just like we did with the method name.

## Data from Signature

Our goal now it to extract all the information that we need for tracing directly from the method definition that invoked the macro. This is where the rich API provided by `Symbol` comes in very handy.

By querying the `Symbol` that owns the macro invocation, we can get all the info we need:
- The name of the method, to be used as ID
- The name of the arguments of the method, along with their values to be used as fields

Since methods in Scala can be quite involved, we need to be careful and make sure that we extract the correct info. For that we'll have to lean even more into the macro Reflection API.

`trace5` is going to be the same as `trace4` but we will no longer require anything other than the tracing level and tracer, everything else will be handled by the macro.

First some helper functions that will need.

```scala wrap=false
def getEnclosingMethodSymbol(using Quotes): quotes.reflect.Symbol = // 1
  import quotes.reflect.*

  Symbol.spliceOwner.owner match
    case methodSymbol if methodSymbol.isDefDef => methodSymbol
    case _ => report.errorAndAbort("trace can only be used at the top-level of a method")
```
This helper extracts the `Symbol` of the method that encloses the macro call, this is pretty much the same code we saw before extracted into a reusable function.

Note how the signature of the helper uses a path-dependent type (1). The reflection API depends on the specific `Quotes` instance, and we have to reflect[^noPun] that by using the magic `quotes.reflect` prefix.

[^noPun]: No pun here, none at all.

```scala wrap=false
def isGiven(using Quotes)(param: quotes.reflect.Symbol) =
  import quotes.reflect.*

  val flags = param.flags // 1

  flags.is(Flags.Given) || flags.is(Flags.Implicit) // 2
```

`isGiven` checks whether a `Symbol` that corresponds to a method argument is a given parameter. We do this by extracting the symbol's `Flags` (1), these contain lots of useful metadata about symbols. We then verify that the `Symbol` is neither `given` nor `implicit` (for legacy reasons) (2).

```scala wrap=false
def isByName(using Quotes)(param: quotes.reflect.Symbol) =
  import quotes.reflect.*

  param.info match // 1
    case ByNameType(_) => true // 2
    case _ => false

```

Similarly, `isByName` checks whether a method argument is a by-name argument. We do this by getting the `info` field of the parameter (1), which contains type information about the `Symbol`. By matching with the custom extractor `ByNameType` (2) on the `info` value, we can decide whether this is a by-name argument or not.

```scala wrap=false
def isUntraceable(using Quotes)(param: quotes.reflect.Symbol) =
  import quotes.reflect.*

  // 1
  param.info =:= TypeRepr.of[UntraceableData]
```

For reasons that will become clear later on, we have a helper that checks whether a symbol is of the `UntraceableData` type. We do this again by using the `info` field, and we type-compare it to the `TypeRepr` of `UntraceableData` (1).

With these helpers in hand, we are ready to tackle `trace5`. Brace yourselves:

```scala wrap=false
object DataFromSignature:
  inline def trace5[A](level: TraceLevel) // 1
                      (inline body: A)
                      (using tracer: Tracer): A =
    ${ trace5Impl('level, 'body, 'tracer) }

  def trace5Impl[A: Type](level: Expr[TraceLevel],
                          body: Expr[A],
                          tracer: Expr[Tracer])
                         (using Quotes): Expr[A] =
    import quotes.reflect.*

    val enclosingMethod = getEnclosingMethodSymbol // 2

    val allParams = enclosingMethod.paramSymss // 3
      .flatten // 4

    val onlyTermParams = allParams.filter(_.isTerm) // 5

    val params = onlyTermParams
      .filterNot(isGiven) // 6
      .filterNot(isByName) // 7
      .filterNot(isUntraceable) // 8

    def toField(param: Symbol) = // 9
      val fieldName = Expr(param.name) // 10
      val fieldValue = Ref(param).asExpr // 11

      '{ $fieldName -> $fieldValue.toString } // 12

    val fieldsList = params.map(toField) // 13
    val fields = Expr.ofSeq(fieldsList) // 14

    val name = Expr(enclosingMethod.name) // 15

    '{ WithInlining.trace1($level, $name, $fields*)($body)(using $tracer) } // 16
```

Step by step:
- `trace5` now only needs the `TracingLevel` and `Tracer` to be able to function (1), no metadata necessary
- We get the symbol for the method that invoked the macro (2)
- Through this `Symbol` we have access to all the information that the compiler has about the invoker of the macro
- We proceed by getting the arguments of the calling method using `paramSymss` (3)[^usefulParams]
- As Scala methods can have multiple argument list, `paramSymss` returns a nested list
- We don't care about the distinction of the different argument lists, we'll be tracing them all, so we flatten everything into one big list of parameters (4)
- Method argument lists can contain both type arguments and term arguments, we only care about tracing the latter, so we filter and keep only `Term` arguments (as opposed to `Type` arguments) (5)
- Before we convert the parameters into tracing fields, we need to filter out some parameters that we don't want to be traced automatically
- The filters are defined in the helper functions above, and they filter out:
  - `given` parameters are usually "special" (like an instance of a `Tracer`) (6)
  - By-name parameters are also prone to being special and evaluating them just for tracing might be the wrong thing to do (7)
  - Some types might be "untraceable" in the sense that the user doesn't want them logged, for example, if they contain sensitive information
  - In our case the suggestively named `UntraceableData` should not be traced, so we filter it out (8)
- For every parameter symbol that we get we are going to create a corresponding expression with the tracing field's name and the field's value (9)
- The name is just the parameter's name as it appears in the traced method's argument list (10)
- The value is a reference to the argument as it was received by the method (11)
- We don't really care about the type of the reference as we are going to `toString` it, so we convert it into an untyped `Expr[Any]` (11)
- This is again the code that the user had to write manually per field before, now it's generated by the macro as a quote (12)
- We use `toField` to convert every parameter that we want to trace into a tuple of field name and value (13)
- And merge everything using `Expr.ofSeq` into one big `Expr` with a `Seq` in it so that we can pass it as varargs below (14)
- Before we can do that, we extract the name of the method directly from its symbol (15)
- Now that we have all the info we need, we can create a quote with a call to `trace1`[^reuseTrace4] where both the `name` and the `fields` arguments were precomputed by this macro (16)

[^usefulParams]: `paramSymss` will only return anything useful if this symbol corresponds to a method, which should be checked by `getEnclosingMethodSymbol`.
[^reuseTrace4]: We could reuse the logic from `trace4Impl` but that would require us to adapt the code a bit so that `fields` are in an unnamed `Vararg` format, but reusing `trace1` makes this code more compatible with the following examples.

And a slightly more involved usage example:
```scala wrap=false
class DataFromSignatureUsage:
  import DataFromSignature.*

  private given tracer: Tracer = Tracer.make[DataFromSignatureUsage]

  // 1
  def theMethodToBeTraced[A <: Int](arg1: => String,
                                    arg2: A,
                                    arg3: SomeData,
                                    arg4: UntraceableData)
                                   (using arg5: Boolean): String =
    trace5(TraceLevel.Info):
      if arg2 > 2 then "hello"
      else "bye"
```

Here we have both type and argument lists (1). We also have all the things that we shouldn't trace (by-names, `UntraceableData`, and a given argument). The resulting generated code traces all the valid arguments and the enclosing method's name without us needing to specify any of those.


<details>
<summary>Click here to see the generated code</summary>

```scala wrap=false
def theMethodToBeTraced[A >: Nothing <: Int](arg1: => String, arg2: A, arg3: SomeData, arg4: UntraceableData)( using arg5: Boolean): String =
  (if this.tracer.isLevelEnabled(TraceLevel.Info) then
    {
      this.tracer.start(TraceLevel.Info,
        "theMethodToBeTraced",
        [ArrowAssoc[String]("arg2").->[String](arg2.toString()), // <--- 1
          ArrowAssoc[String]("arg3").->[String](arg3.toString()) :
          (String, String)]**
      )
      try 
        {
          val result: String = if arg2.>(2) then "hello" else "bye"
          this.tracer.finish(TraceLevel.Info,
            "theMethodToBeTraced",
            [ArrowAssoc[String]("result").->[String](result.toString()) :
              (String, String)]*
          )
          result:String
        }
      catch 
        {
          case scala.util.control.NonFatal(e @ _) =>
            this.tracer.finish(TraceLevel.Info,
              "theMethodToBeTraced",
              [ArrowAssoc[String]("exception").->[String](e.toString()) :
                (String, String)]*
            )
            throw e
        }
    }
  else if arg2.>(2) then "hello" else "bye"):String:String
}
```

In (1) we see that both arguments from the method's signature that are eligible for tracing were inserted in the correct place.
</details>

With `UntraceableData` we've opened up a new potential problem. Hardcoding `UntraceableData` into our macro is very inflexible. What if the user wants to customize what should be traced and what not? And how do we decide whether to trace or not types that are not available during the compilation of the macro?

##  Trace Filtering

We want a more robust way to filter out data that shouldn't be traced. To that end we are going to use the following typeclass:
```scala wrap=false
trait ToTrace[A]:
  def toTraceString(value: A): String
```

The `ToTrace` typeclass is just a function to convert a value into a string that can be used for tracing output. We'll use the typeclass to determine which parameters should or should not be traced.

If an instance of `ToTrace` is available for a type then we can trace it. This way, the user can easily determine which parameters should or should not be traced automatically, and customize the tracing output. Also, using `toString` for tracing seems barbaric and crude, `ToTrace` allows us to have better control of the tracing output.

`trace6` is going to be equivalent to `trace5`, but instead of hardcoding a dependency on `UntraceableData` it's going to use the presence or lack thereof of `ToTrace` as a filter. Here, for the first time we'll see the interaction of givens resolution and macros. Both things happen at compile-time, and joining them isn't too complicated if we are careful[^macroSummon].

[^macroSummon]: See [this](https://softwaremill.com/scala-3-macros-tips-and-tricks/#typechecking-and-summoning-givens) discussion about summoning givens in a macro.

To achieve this goal we are going to use a new version of `toField`. The new `toField` implementation will also convert a `Symbol` into a pair of name and reference `name -> value`. But now it will also check whether there is a `ToTrace` instance in scope and respond accordingly.
```scala wrap=false
def toField(using Quotes)
           (param: quotes.reflect.Symbol): Option[Expr[(String, String)]] = // 1
  import quotes.reflect.*

  val fieldName = Expr(param.name) // 2

  val paramType = param.info.asType // 3

  val maybeField = paramType match // 4
    case '[t] => // 5
      val maybeTraceable = Expr.summon[ToTrace[t]] // 6
      val fieldValue = Ref(param).asExprOf[t] // 7

      maybeTraceable.map: traceable => // 8
        '{ $fieldName -> $traceable.toTraceString($fieldValue) } // 9

  maybeField
```

Step by step:
- The signature changed and now the result is wrapped in `Option`, since we might decide to skip from tracing this symbol (1)
- As before, we need the name of the parameter which we extract directly from the `Symbol` (2)
- To be able to summon a `ToTrace` instance, we need the type of the parameter we are currently dealing with
- We use `info` to get a `Type` instance for this `Symbol` (3)
- Since we obtained the type of the parameter using reflection, we need an extra step to be able to name it in code, so we match on it (4)
- By matching on the unknown type we can give it a name, `t` in this case, that we can refer to in the code below (5)
- We summon an instance of `ToTrace` for this unknown type, the result is an `Option`, which will be `None` if no instance was found for `t`[^evaluationTime] (6)
- With this `Option` we can apply some conditional logic depending on whether it's present or not
- We create a reference to the parameter (7)
- Unlike before, this time we care about the type of the reference, it can't be `Any`, as we need the types to align in the quote below
- To that end, we are casting the reference to `t`, which is safe, since we got this type from matching on this very symbol's type (7)
- If we do indeed have a `ToTrace` instance, we are going to call it with the parameter's value (in `map`), but if we got a `None` here we are just going to skip this parameter entirely (8)
- The result is a quote with a name/value, but instead of calling `toString` we use `toTraceString` (9), due to the cast above, all the types in the quote align and the quote is well-typed

[^evaluationTime]: The given resolution is going to happen when the macro is applied by the user, at which point the actual type `t` is going to be known, and will be used in the givens search.

To avoid repetition down the line, here are some helpers that encapsulate some parts of the logic that we had in `trace5`:
```scala wrap=false
def getEnclosingMethodParams(using Quotes) =
  getEnclosingMethodSymbol.paramSymss.flatten.filter(_.isTerm)

def getEnclosingMethodName(using Quotes): Expr[String] =
  Expr(getEnclosingMethodSymbol.name)
```

Hopefully, by now the names of these functions are self-explanatory.

Now we are ready to implement `trace6`, which is similar to but more civilized than `trace5`:
```scala wrap=false
object TraceFiltering:
  inline def trace6[A](level: TraceLevel) // 1
                      (inline body: A)
                      (using tracer: Tracer): A =
    ${ trace6Impl('level, 'body, 'tracer) }

  def trace6Impl[A: Type](level: Expr[TraceLevel],
                          body: Expr[A],
                          tracer: Expr[Tracer])
                         (using Quotes): Expr[A] =
    import quotes.reflect.*

    val params = getEnclosingMethodParams // 2
      .filterNot(isGiven) // 3
      .filterNot(isByName)

    val fieldsList = params.flatMap(toField) // 4

    val fields = Expr.ofSeq(fieldsList) // 5

    val name = getEnclosingMethodName // 6

    // 7
    '{ WithInlining.trace1($level, $name, $fields*)($body)(using $tracer) }
```

In this implementation:

- We define our tracing function with the same signature as before (1)
- Like before we get a list of symbols for all the parameters of the method (2)
- Yet again, we filter away given and by-name parameters, but we do not explicitly filter out `UntraceableData` (3)
- Then we convert every parameter into a field but this time we are going to use the `ToTrace` typeclass to determine how to trace each parameter, which is what `toField` is doing (4)
- Note that we are using `flatMap` here, as `toField` can potentially filter out some of the parameters (by returning `None`), but we no longer have to explicitly hardcode `UntraceableData` into the macro's logic (4)
- Lastly we turn everything into a single list, and get the name of the enclosing method (5) and (6)
- Now that everything is ready, we can call `trace1` with the data we prepared[^onlyTrace1] (7)

[^onlyTrace1]: Here we can only use `trace1`, as `trace4Impl` uses `toString` to convert the fields into values, whereas here we want to use the result of `toTraceString`.

The usage example is pretty much the same as before:
```scala wrap=false
class TraceFilteringUsage:
  import TraceFiltering.*

  given tracer: Tracer = Tracer.make[TraceFilteringUsage]

  def theMethodToBeTraced(arg1: String,
                          arg2: Int,
                          arg3: SomeData,
                          arg4: UntraceableData): String =
    trace6(TraceLevel.Info):
      if arg2 > 2 then "hello"
      else "bye"
```


Tracing still works the same, but `UntraceableData` is omitted because it doesn't have a `ToTrace` instance in scope, as can be seen in the generated code.


<details>
<summary>Click here to see the generated code</summary>

```scala wrap=false
def theMethodToBeTraced(arg1: String, arg2: Int, arg3: SomeData, arg4: UntraceableData): String =
  (if this.tracer.isLevelEnabled(TraceLevel.Info) then
    {
      this.tracer.start(TraceLevel.Info,
        "theMethodToBeTraced",
        [
          ArrowAssoc[String]("arg1").->[String](
            ToTrace.given_ToTrace_String.toTraceString(arg1)) // <--- 1
            ,
          ArrowAssoc[String]("arg2").->[String](
            ToTrace.given_ToTrace_Int.toTraceString(arg2)),
          ArrowAssoc[String]("arg3").->[String](
            SomeData.given_ToTrace_SomeData.toTraceString(
              arg3)
          )
        : (String, String)]**
      )
      try
        {
          val result: String = if arg2.>(2) then "hello" else "bye"
          this.tracer.finish(TraceLevel.Info,
            "theMethodToBeTraced",
            [ArrowAssoc[String]("result").->[String](result.toString()) :
              (String, String)]*
          )
          result:String
        }
      catch
        {
          case scala.util.control.NonFatal(e @ _) =>
            this.tracer.finish(TraceLevel.Info,
              "theMethodToBeTraced",
              [ArrowAssoc[String]("exception").->[String](e.toString()) :
                (String, String)]*
            )
            throw e
        }
    }
  else if arg2.>(2) then "hello" else "bye"):String:String
}
```

In (1) we see the invocation of the appropriate `ToTrace.toTraceString` functions for each type of argument.
</details>


We can also run the example like so:
```scala wrap=false
object TraceFilteringUsage:
  @main def traceFiltering() =
    val usage = new TraceFilteringUsage

    usage.theMethodToBeTraced("abc", 123, SomeData(4, "password"), UntraceableData('d', "efg"))
```

And in the output we see that one of the fields of `SomeData` (suggestively named `sensitiveDoNotLog`) appears as "redacted", this is a customization that we applied using `SomeData`'s `ToTrace` instance:

```txt wrap=false
[info][TraceFilteringUsage]: *start* theMethodToBeTraced arg1: abc, arg2: 123, arg3: SomeData(4, <redacted>)
[info][TraceFilteringUsage]: *finish* theMethodToBeTraced result: hello
```
The `ToTrace` typeclass not only solved the hardcoding issue, but we also gained added flexibility by not relying on the builtin `toString`.

We got pretty much as far as we can go with automating boilerplate with a `def` macro. But still, this is not as smooth as it can be, we still have to modify the body of the method just to apply automated tracing to it. This limitation can be circumvented by using macro annotations.

##  No Given Tracer

Before we move on to macro annotations, a quick digression. We'll create a small variation of `trace6` which is essentially the same thing as `trace6` but instead of taking a `given` `Tracer` instance directly it takes an explicit fallback instance. The new logic will be to try to find an in-scope given instance using `Expr.summon` and only use the fallback instance if a given is not found. We won't be using this example on its own, but only as a helper in examples down the road.

The point of this is that we can invoke `trace7` in a macro without there being a statically known (at macro compile-time) instance of a `Tracer`, and the resolution of the `Tracer` instance will be deferred to macro inlining time in the scope of the caller. This will help us circumvent some limitations with macro annotations down the line.

```scala wrap=false
object NoGivenTracer:
  // 1
  inline def trace7[A](level: TraceLevel, fallbackTracer: Tracer)(inline body: A): A =
    ${ trace7Impl('level, 'fallbackTracer, 'body) }

  def trace7Impl[A: Type](
      level: Expr[TraceLevel],
      fallbackTracer: Expr[Tracer],
      body: Expr[A])(using Quotes): Expr[A] =
    import quotes.reflect.*

    val params = getEnclosingMethodParams
      .filterNot(isGiven)
      .filterNot(isByName)

    val fieldsList = params.flatMap(toField)
    val fields = Expr.ofSeq(fieldsList)

    val name = getEnclosingMethodName
    // 2
    val tracer = Expr.summon[Tracer].getOrElse(fallbackTracer)

    '{ WithInlining.trace1($level, $name, $fields*)($body)(using $tracer) }
```

- The signature of `trace7` is almost the same as `trace6` except that the `Tracer` instance is no longer a given, we treat it as an explicit fallback (1)
- The rest of the code is almost the same, up until the point we are about to call `trace1`
- Here we explicitly summon the `Tracer` but use a fallback in case it's not found, it's important that summoning is happening within the scope of the (non-macro) caller of `trace7` (2)

The ability to resolve the `Tracer` as a given, while having a fallback instance in place, will turn out to be useful later on.

##  Method Annotation

We are now going to define a macro annotation that will fully automate the tracing process without directly touching the body of the method. We still need to be able to choose the tracing level, so we are going to pass it as an argument directly to the annotation.

This poses a problem, as arguments to annotations are just regular constructor arguments (see below), and not `Expr`s like the arguments to a macro method. This means that for every annotation argument that we receive, if we want to use it within quotes generated by the macro we must have a `ToExpr` in scope. This happens automatically for simple builtin types like `Int`, but we need to define one ourselves for our custom `TracingLevel` type.

Here is that definition:
```scala wrap=false
given ToExpr[TraceLevel] with

  def apply(level: TraceLevel)(using Quotes): Expr[TraceLevel] =
    // 1
    level match
      case TraceLevel.Debug => '{ TraceLevel.Debug }
      case TraceLevel.Info => '{ TraceLevel.Info }
      case TraceLevel.Warn => '{ TraceLevel.Warn }
      case TraceLevel.Error => '{ TraceLevel.Error }
```
The definition of `ToExpr` for simple enums is straightforward. We just match on the value we got, and create a corresponding quote for each case (1).

Another point to consider is how do we want to obtain a `Tracer` instance. Passing it as a constructor argument is a no go. Both because it requires initialization that we cannot do statically, and because it will prevent our users from being able to work with `Tracer`s as given arguments.

Instead, we are not going to receive a `Tracer` explicitly but rather try and summon a `Tracer` instance from within the macro. What we want to achieve is that we get the `given` tracer that would've been available had the macro generated code been written directly in the method that was annotated[^spirit]. Whether it was given directly in the method's signature, or from somewhere else, like the class scope, where we placed the `Tracer` in the examples so far. For that we use `summonInline`, relying on the fact that `summonInline` should behave like `Expr.summon`. That is, the summoning is happening in the correct scope (the method's inner scope). But unlike `Expr.summon` we are spared from coming up with our own error message in case a `Tracer` is missing (we'll get the standard compiler error)[^notSummonInline].

[^spirit]: Like [so](https://www.reddit.com/r/linguisticshumor/comments/zmqqn6/the_ghost_of_christmas_future_imperfect/).
[^notSummonInline]: You might ask why not use `summonInline` all the time, and one reason might be the need to apply conditional logic within a macro like we had above. `summoFrom` is another (less flexible) way to achieve conditional logic during givens resolution.

With these issues out of the way, let's proceed to the implementation. Macro annotations work by transforming a `Definition` that corresponds to the AST of the target that they were applied to. In our case the target we will support is a single method, which we will transform by applying tracing to it. Like so:
```scala wrap=false
import scala.annotation.MacroAnnotation

// 1
class traceMethod(level: TraceLevel) extends MacroAnnotation:

  // 2
  def transform(using Quotes)
               (definition: quotes.reflect.Definition,
                companion: Option[quotes.reflect.Definition]): List[quotes.reflect.Definition] =
    import quotes.reflect.*

    definition match // 3
      case defDef @ DefDef(name, _, _, Some(rhsTree)) => // 4
        val levelExpr = Expr(level) // 5
        val nameExpr = Expr(name) // 6

        val tracer = '{ compiletime.summonInline[Tracer] } // 7

        val newRhs = rhsTree.asExpr match // 8
          case '{ $body: t } => // 9
            '{ TraceFiltering.trace6($levelExpr)($body)(using $tracer) } // 10

        val newTree = DefDef(defDef.symbol, _ => Some(newRhs.asTerm)) // 11

        List(newTree) // 12

      case _ => // 13
        report.errorAndAbort("Tracing is only supported on a non-abstract `def`")
```
This looks quite different compared to what we had so far, as macro annotations have their own way to operate on code. Let's walk trough the code step by step:
- We define a new class that extends `MacroAnnotation` (1), this is what lets us turn this annotation into magic
- To be able to accept a tracing level from the user, the annotation takes a `TraceLevel` argument (1), this is the only argument that it needs to receive explicitly (the `Tracer` will be resolved from given scope)
- The `transform` method follows the signature dictated by `MacroAnnotation`, which gives us access to the `Definition` that the annotation was applied to (2)
- In this annotation we are only going to support non-abstract methods, so we match on the provided definition that the annotation was applied to (3)
- We match only `def` nodes, with a non-empty `rhsTree`, its presence indicates that the method is not abstract (4)
- To be able to use the `TraceLevel` argument `level` that we got in the quotes we are about to write, we need to turn it into an `Expr`, for this purpose we use the `ToExpr` instance we just defined (summoned by `Expr.apply`) (5)
- We extract the name of the method directly from the pattern match (rather than using the `Symbol` for the method) (6)
- To obtain the given `Tracer` in the traced method's scope we use `summonInline` as described above (7)
- Now we are going to rewrite the implementation of the method we are instrumenting
- We cast the `rhsTree` `Term` (the body of the method being instrumented)  into an `Expr[Any]` (8)
- But to be able to create well-typed quotes we must work with a precise type, otherwise the compiler will use `Any` in the resulting code and will fail to compile (due to a mismatch between `Any` and the actual type of the method)
- We name the type by matching on the expression, this way we are getting the exact type of the expression, which we name `t` (9)
- Just by naming the type this way the compiler is forced to preserve the precise type of our `Expr`, even though we do not actually use this name here
- For the actual new implementation of the method, we just call `trace6`, our most automated def macro, and let it fully instrument the old body of the method (10)
- We're using the macro call rather than its `impl` because we want the macro to properly initialize a `Quotes` instance in the right scope (or else the `owner` of this macro call and various givens might not resolve correctly)
- We create the new method definition with the transformed body (11)
- The newly instrumented method is returned as the output of the macro annotation, to replace the original `def` it was applied to (12)
- In case the annotation was applied to anything but an non-abstract method, we gracefully error out (13)

Phew, that was plenty. But does it actually work?

It seems so:
```scala wrap=false
class MethodAnnotationUsage:
  // 1
  given Tracer = Tracer.make[ClassAnnotationUsage]

  // 2
  @traceMethod(TraceLevel.Debug)
  def theMethodToBeTraced1(arg1: String,
                           arg2: Int,
                           arg3: SomeData,
                           arg4: UntraceableData): String =
    if arg2 > 2 then "hello"
    else "bye"

  // 3
  @traceMethod(TraceLevel.Info)
  def theMethodToBeTraced2(arg1: String,
                           arg2: Int,
                           arg3: SomeData,
                           arg4: UntraceableData)
                          (using Tracer): String = // 4
    if arg2 > 2 then "hello"
    else "bye"
```

Here we exercise the annotation with different method setups:
- We set up the tracer that's going to be used by default within this class (1)[^commentOut]
- We'll be tracing the first method at the debug level (2)
- And the second method at the info level (3)
- Within the second method we should be using the more specific tracer passed in as an argument, rather than the default one defined above (4)

[^commentOut]: If we comment this out, the code won't compile. Unfortunately the error message seems to point directly into the macro's code rather than showing the correct location where the macro is actually expanded.

We can see that everything works out the way we intended in the generated code.

<details>
<summary>Click here to see the generated code</summary>

```scala wrap=false
final lazy given val given_Tracer: Tracer =
  Tracer.make[ClassAnnotationUsage](
    scala.reflect.ClassTag.apply[ClassAnnotationUsage](
      classOf[ClassAnnotationUsage])
  )

@traceMethod(TraceLevel.Debug) def theMethodToBeTraced1( arg1: String, arg2: Int, arg3: SomeData, arg4: UntraceableData): String =
  (if this.given_Tracer.isLevelEnabled(TraceLevel.Debug) then // <--- 1 

    {
      this.given_Tracer.start(TraceLevel.Debug,
        "theMethodToBeTraced1",
        [
          ArrowAssoc[String]("arg1").->[String](
            ToTrace.given_ToTrace_String.toTraceString(arg1))
            ,
          ArrowAssoc[String]("arg2").->[String](
            ToTrace.given_ToTrace_Int.toTraceString(arg2)),
          ArrowAssoc[String]("arg3").->[String](
            SomeData.given_ToTrace_SomeData.toTraceString(
              arg3)
          )
        : (String, String)]**
      )
      try 
        {
          val result: ("hello" : String) | ("bye" : String) =
            if arg2.>(2) then "hello" else "bye"
          this.given_Tracer.finish(TraceLevel.Debug,
            "theMethodToBeTraced1",
            [ArrowAssoc[String]("result").->[String](result.toString()) :
              (String, String)]*
          )
          result:("hello" : String) | ("bye" : String)
        }
      catch 
        {
          case scala.util.control.NonFatal(e @ _) =>
            this.given_Tracer.finish(TraceLevel.Debug,
              "theMethodToBeTraced1",
              [ArrowAssoc[String]("exception").->[String](e.toString()) :
                (String, String)]*
            )
            throw e
        }
    }
  else if arg2.>(2) then "hello" else "bye"):
    ("hello" : String) | ("bye" : String):
    ("hello" : String) | ("bye" : String)
@traceMethod(TraceLevel.Info) def theMethodToBeTraced2(arg1: String, arg2: Int, arg3: SomeData, arg4: UntraceableData)(using x$5: Tracer): String =
  (if x$5.isLevelEnabled(TraceLevel.Info) then // <--- 2
    {
      x$5.start(TraceLevel.Info, "theMethodToBeTraced2",
        [
          ArrowAssoc[String]("arg1").->[String](
            ToTrace.given_ToTrace_String.toTraceString(arg1))
            ,
          ArrowAssoc[String]("arg2").->[String](
            ToTrace.given_ToTrace_Int.toTraceString(arg2)),
          ArrowAssoc[String]("arg3").->[String](
            SomeData.given_ToTrace_SomeData.toTraceString(
              arg3)
          )
        : (String, String)]**
      )
      try 
        {
          val result: ("hello" : String) | ("bye" : String) =
            if arg2.>(2) then "hello" else "bye"
          x$5.finish(TraceLevel.Info,
            "theMethodToBeTraced2",
            [ArrowAssoc[String]("result").->[String](result.toString()) :
              (String, String)]*
          )
          result:("hello" : String) | ("bye" : String)
        }
      catch 
        {
          case scala.util.control.NonFatal(e @ _) =>
            x$5.finish(TraceLevel.Info,
              "theMethodToBeTraced2",
              [ArrowAssoc[String]("exception").->[String](e.toString()) :
                (String, String)]*
            )
            throw e
        }
    }
  else if arg2.>(2) then "hello" else "bye"):
    ("hello" : String) | ("bye" : String):
    ("hello" : String) | ("bye" : String)
}
```

As promised, in (1) we are using the class's tracer at the debug level, and in (2) method argument's tracer at the info level.

</details>

To see that we actually are picking up the correct tracers, let's try to run the code:
```scala wrap=false
object MethodAnnotationUsage:
  @main def methodAnnotation() =
    val usage = new MethodAnnotationUsage

    // 1
    usage.theMethodToBeTraced1("abc", 123, SomeData(4, "password"), UntraceableData('d', "efg"))

    locally:
      // 2
      trait OtherTracer
      given Tracer = Tracer.make[OtherTracer]

      // 3
      usage.theMethodToBeTraced2("abc", 123, SomeData(4, "password"), UntraceableData('d', "efg"))
```

When calling the first method (1) we get the default tracer:
```txt wrap=false
[debug][ClassAnnotationUsage]: *start* theMethodToBeTraced1 arg1: abc, arg2: 123, arg3: SomeData(4, <redacted>)
[debug][ClassAnnotationUsage]: *finish* theMethodToBeTraced1 result: hello
```

Next we create another scope with a another tracer, which we mark with a different name, so as to distinguish it from the default tracer (2). We can see in the output that `OtherTracer` is picked by the macro (3): 
```txt wrap=false
[info][OtherTracer]: *start* theMethodToBeTraced2 arg1: abc, arg2: 123, arg3: SomeData(4, <redacted>)
[info][OtherTracer]: *finish* theMethodToBeTraced2 result: hello
```

We are getting very close to auto-tracing nirvana, but there's still some repetition here. We can imagine wanting to trace all the methods of a whole class. Why should we be repeatedly marking them one by one?

## Class Annotation

To make everything fully-automatic, we're going to define a macro annotation that works on class definitions, automatically applying tracing to all methods of a class[^splitAnnotation].

[^splitAnnotation]: We could've done that with the method annotation as well, just by adding another branch to the pattern match there. We split things up for pedagogical reasons.

The logic we'll implement is as follows:
- Apply the annotation to a whole class
- The annotation has an argument specifying the default tracing level
- If not already present, create a fallback `Tracer` as a member of the class, to be used by methods that don't have their own given `Tracer`
- For every non-abstract method on the annotated class
- Check whether the class has the `traceAt` annotation (to be defined below)
- If it does, apply tracing (with a given or fallback `Tracer`) to the method at the level specified by the `traceAt` annotation
- If not, apply tracing to the method with the default level

As we are venturing into more experimental realms, more things tend to break...

Before we can proceed to implementing the annotation itself we'll need a bunch of helper building blocks.

### Custom Tracing Levels

First, let's define the helper `traceAt` annotation, that will let us override the default tracing level on per method basis:
```scala wrap=false
import scala.annotation.StaticAnnotation

case class traceAt(level: TraceLevel) extends StaticAnnotation
```
This time we are defining a regular, static, annotation. To be available only at compile-time, and hence visible to any macros that we are going to write.

This annotation has a single field: the `TraceLevel` that will be supplied by the user.

When processing the `traceAt` annotation the macro is going to receive it as part of the AST it will work on. This means that instead of the annotation value, we'll have to deal with an `Expr[traceAt]`. To make it usable within the macro code, we need to define a `FromExpr` instance for `traceAt`. Since `traceAt` contains a `TraceLevel` value, we need to define a `FromExpr` instance for it as well:

```scala wrap=false
given FromExpr[TraceLevel] with
  def unapply(x: Expr[TraceLevel])(using Quotes): Option[TraceLevel] =
    x match // 1
      case '{ TraceLevel.Debug } => Some(TraceLevel.Debug)
      case '{ TraceLevel.Info } => Some(TraceLevel.Info)
      case '{ TraceLevel.Warn } => Some(TraceLevel.Warn)
      case '{ TraceLevel.Error } => Some(TraceLevel.Error)
      case _ => None
```
This is almost a mirror image of the `ToExpr` instance we defined above. We are matching quotes with the different possible `TraceLevel`s and convert them to the corresponding values (1).
Note that unlike a regular pattern match, when matching on quotes, nothing is forcing us to check all the cases. If we add a new case, this code will fail silently (that is, at compile-time when a user invokes the macro), there's no way to turn on exhaustivity checking for quotes (to be checked at macro definition time).

Now we can create the `FromExpr` instance for `traceAt`:

```scala wrap=false
given FromExpr[traceAt] with
  def unapply(x: Expr[traceAt])(using Quotes): Option[traceAt] =
    x match // 1
      case '{ new `traceAt`($level) } => Some(traceAt(level.valueOrAbort)) // 2
      case '{ `traceAt`($level) } => Some(traceAt(level.valueOrAbort))
      case _ => None
```

Because `traceAt` is not a simple enum, we match on all the ways to construct a `traceAt` value we can think of and then convert them to the appropriate values (1). We use `valueOrAbort` (2) to convert the inner `level` `Expr` into a value, which in turn relies on the `FromExpr` instance we just defined for `TraceLevel`. 

### Creating a `Tracer` Instance

The next component we'll need is a way to define a new `Tracer` as a member of the class that we want to instrument. This means creating a new `Tree` node that the macro annotation will add to its output and will eventually be spliced into the class we are instrumenting.

Creating new members in a class is a superpower only available to macro annotations. Although it's a limited superpower as any new member we add from within the macro won't be visible outside the class the annotation was applied to.

Assuming we're instrumenting a class name `MyClass`, we want to create the equivalent of this code:
```scala wrap=false
private final lazy val tracer = Tracer.make[MyClass]
```
The definition is private and final for encapsulation purposes, but as noted above, macro generated definitions aren't visible on the outside anyways. Additionally, we mark the definition as `lazy`. Although it makes sense to make this definition lazy (it might not be used if all methods do not require a tracer[^avoidVal]), it's actually mandatory, otherwise the macro won't work for traits and will crash the compiler, go figure...

[^avoidVal]: Left as a (difficult) exercise to the reader to come up with how to make the macro avoid the creation of the new `val` if it won't be used in any of the instrumented methods.

What is missing from the modifiers of the tracer we are about to create is `given`. In a perfect world we would mark this definition as given and then the usual rules for givens would kick in. The instrumentation code could use this `Tracer` where no others are available and ignore it when another tracer is present. Unfortunately, the givens resolution process will ignore any given definitions that we are adding from within the macro, and they won't be picked up in the code that will be instrumented. The only way for us to use the new definition is to pass it around explicitly[^givenIssue].

[^givenIssue]: Trying the approaches described in this [issue](https://github.com/lampepfl/dotty/issues/12359) didn't lead to any improvements.

This is where `trace7` comes in. Recall that `trace7` has the same logic as our full instrumentation (`trace6`), but instead of using a given `Tracer` it tries to resolve one within the body of `trace7`, and use an explicitly passed fallback in case no `Tracer` was found. The definition that we create here will be passed to `trace7` as an explicit fallback in case no given value can be resolved at the instrumentation site.

Here's how we create the new definition:
```scala wrap=false
  def makeTracer(using Quotes)(cls: quotes.reflect.Symbol) =
    import quotes.reflect.*

    val tracerSymbol = // 1
      Symbol.newVal(
        parent = cls, // 2
        name = Symbol.freshName("tracer"), // 3
        tpe = TypeRepr.of[Tracer],
        flags = Flags.Final | Flags.Lazy | Flags.Private, // 4
        privateWithin = Symbol.noSymbol)

    val tracerRhs = // 5
      given Quotes = tracerSymbol.asQuotes // 6

      cls.typeRef.asType match // 7
        case '[t] =>
          '{ Tracer.make[t](using compiletime.summonInline) }.asTerm // 8

    val tracerVal = ValDef(tracerSymbol, Some(tracerRhs)) // 9

    tracerVal
```

- We create a brand new `val`, starting with a `Symbol` for it (1)
- The new symbol is nested within the provided class by setting the class's symbol as the parent of this new symbol we are now creating (2)
- To avoid possible name clashes, we use a fresh name (3)
- We set the appropriate flags, this applies the required modifiers to the resulting `val` (4)
- Now we need to define how to create the `Tracer` (5)
- We make sure to use the correct scope when creating quotes, which is the scope of the freshly created symbol (6)
- Since the class is passed in "dynamically"[^upfront], we need to match on its type to have a name for its type that can be used in a quote (7)
- We create quote with a new `Tracer` for the class (8)
- To create it we need to provide a `ClassTag`, since we don't statically (at macro definition time) know the type here, we use `summonInline` to be evaluated later when the macro is expanded and the actual type is known (8)
- We assemble the symbol and the RHS into a single definition (9)

[^upfront]: We don't know upfront what class the annotation is going to be applied to.

### Computing a Fallback `Tracer`

Now that we have the ability to create new `Tracer` instances we can use it within the logic of getting the `Tracer` that will be supplied as fallback to methods instrumented by the macro. We want to implement this strategy for obtaining a `Tracer`:
  - If a `given` tracer was defined on the class by the user, we use that
  - Otherwise, we create a new (private) `Tracer` as a private member of the class

But there is a wrinkle, in case we want to create a new definition and actually use it, we need two things: a reference to the new definition, and a `Tree` that constructs it as a member of the class, so that it can be added to the class definition[^allHell]. Meaning that we need to return both a reference to a `Tracer` and optionally the `Tree` that was newly created for it. This complication is going to be reflected in the signature below.

[^allHell]: If we don't add it, we'll find ourselves referencing a nonexistent value, and all hell might break loose.

Let's find the `Tracer` for our macro:
```scala wrap=false
// 1
def getOrCreateTracer(using Quotes)
                     (cls: quotes.reflect.Symbol): (Expr[Tracer], Option[quotes.reflect.ValDef]) =
  import quotes.reflect.*

  val maybeTracer = // 2
    given Quotes = cls.asQuotes // 3
    Expr.summon[Tracer]

  maybeTracer match // 4
    case Some(tracer) => (tracer, None) // 5
    case None => // 6
      val tracerDefinition = makeTracer(cls) // 7
      val tracerRef = Ref(tracerDefinition.symbol).asExprOf[Tracer] // 8

      (tracerRef, Some(tracerDefinition)) // 9
```

- The signature reflects the complication described above, and returns a compound value (1):
  - The first part is the `Expr` for the tracer that was either summoned or created
  - In case the tracer was created, we return the `Tree` that corresponds to it
-  We are trying to obtain a given tracer within the scope of the class we are instrumenting, the result will be `None` if no such tracer exists (2)
- We want the given scope to be the scope of the class we are currently processing, if we use the `Quotes` instance provided to the method directly we will be in the package scope, so instead we get the `Quotes` instance belonging to the symbol of the class being instrumented, and only then summon the `Tracer` (3)
- We branch on whether we found a `tracer` or not (4)
- If a provided `Tracer` was found, we are going to return it and not create any new definitions (the `None` part of the result) (5)
- If no given `Tracer` was found, we need to create a new member with a `Tracer` in it (6)
- We create the tracer definition tree using `makeTracer` (7)
- Then we create a reference to the tracer that was just created, to be used by the instrumentation code, we must not forget to add the definition for this value to the output of the macro (8)
- We return both a reference to the newly created `Tracer` and its definition (9)

### Getting the Tracing Level

The next step is to figure out the tracing level for a specific method being instrumented. We do the following:
- If the method has a `traceAt` annotation, get the tracing level from it
- Otherwise return `None`, implying that we'll eventually use the default tracing level passed to our macro annotation

Like so:
```scala wrap=false
def getTracingLevel(using Quotes)
                   (defSym: quotes.reflect.Symbol): Option[TraceLevel] = // 1
  import quotes.reflect.*

  val traceAtSymbol = TypeRepr.of[traceAt].typeSymbol // 2

  defSym
    .getAnnotation(traceAtSymbol) // 3
    .map: annotationTerm => // 4
      val traceAt = annotationTerm
       .asExprOf[traceAt] // 5
       .valueOrAbort // 6

      traceAt.level // 7
```

- The input to our function is the symbol that corresponds to the method being instrumented (1)
- To find a specific annotation we need a `Symbol` for it, so we obtain it from the `TypeRepr` of `traceAt` (2)
- We query for annotations with the symbol for `traceAt` (3)
- If the annotation is present, we extract the `TraceLevel` it contains (4)
- First we cast into `traceAt`, this is safe since this is how we obtained this symbol to begin with (5)
- Then we rely on `traceAt`'s `FromExpr` instance we defined before to extract the value to be available for the macro at compile-time[^canSkip] (6)
- We return the tracing level for the method (7)

[^canSkip]: We could skip this, and just use the annotation as an `Expr` when creating quoted code as output. But if we keep the `Expr` with the annotation, we will get a redundant instantiation of the annotation object at runtime. Instead we extract the actual tracing-level at compile-time and inject it directly into the generated code completely discarding the `traceAt` annotation, so that it doesn't appear at runtime. It can be instructive to try to use the `Expr` `'{ traceAt.level }` and see the generated code.

### Instrumenting All Methods

The final building block that we'll define is the logic that instruments all the methods of a class. As follows:
```scala wrap=false
def traceMethods(using Quotes)
                (body: List[quotes.reflect.Statement], // 1
                 fallbackTracer: Expr[Tracer], // 2
                 defaultLevel: TraceLevel) = // 3
  import quotes.reflect.*

  body.map: // 4
    case defDef @ DefDef(name, _, _, Some(rhsTree)) => // 5
      val tracingLevel =
        Expr(getTracingLevel(defDef.symbol).getOrElse(defaultLevel)) // 6

      val newRhs = rhsTree.asExpr match // 7
        case '{ $body: t } =>
          '{ NoGivenTracer.trace7($tracingLevel, $fallbackTracer)($body) } // 8

      DefDef(defDef.symbol, _ => Some(newRhs.asTerm)) // 9

    case notMethod => notMethod // 10
```

- The method takes as inputs:
  - The definitions of the members of the class to be instrumented (1)
  - A fallback tracer to be used in case a method doesn't have its own `Tracer` in the `given` scope (2)
  - The default level for tracing, in case no explicit level is provided for a method (3)
- For each definition (4)
- We apply tracing only to non-abstract methods, as denoted by the non-empty `rhsTree` (5)
- To know at which level to apply tracing, we first try to obtain the level directly from the `def` itself using `getTracingLevel` (6)
- If no tracing level was defined, we use the default level (6)
- The resulting `TracingLevel` is turned into an `Expr` using the previously defined `ToExpr` instance (6)
- Yet again we have the body of a method (`rhsTree`) as an untyped `Term`, we convert it into an `Expr` and then match on it to obtain a name for its precise type to be used by the quotes below (7)
- Finally, we use `trace7` with the tracing level and the fallback tracer we have, to which we also pass in the method's body, and the result will be a fully instrumented method implementation[^macroScope] (8)
- We copy the `def` with the new instrumented body, and return that (9)
- For anything that's not a non-abstract method we just return it untouched (10)

[^macroScope]: We are calling the `trace7` macro (and not the `impl` version) from within this macro to make sure that the `given` resolution happens in the correct scope, the instrumented method's scope.

Finally! We are ready for the masterpiece we were yearning to implement, the `traceClass` macro annotation.

### Putting It All Together

All the different building blocks we created so far are now coming together in a single macro annotation:
```scala wrap=false
class traceClass(defaultLevel: TraceLevel) extends MacroAnnotation: // 1

  def transform(using Quotes)
               (definition: quotes.reflect.Definition,
                companion: Option[quotes.reflect.Definition]): List[quotes.reflect.Definition] =
    import quotes.reflect.*

    definition match
      case cls @ ClassDef(_, _, parents, _, body) => // 2
        val (fallbackTracer, tracerDefinition) = getOrCreateTracer(cls.symbol) // 3

        val withTracedMethods = traceMethods(body, fallbackTracer, defaultLevel) // 4

        val newBody = tracerDefinition.toList ++ withTracedMethods // 5

        val newClass = ClassDef(cls.symbol, parents, newBody) // 6

        List(newClass) // 7
      case _ =>
        report.errorAndAbort("Tracing is only supported on classes") // 8
```

Our shiny new `traceClass` annotation does the following:
- It takes a default `TraceLevel` that will be used for methods that don't provide their own level (1)
- We match only on class definitions (this includes traits as well) (2)
- To be able to support tracing within the class we want to make sure that the class contains a tracer in scope
- `getOrCreateTracer` handles this for us (3), producing either a `given` tracer that was already present in the class, or creating a new one, this tracer will be used as fallback in `traceMethods`
- In case a new `Tracer` was created, we must keep the definition of the new `Tracer` so that we can later add it to the class
- With the fallback `Tracer` in hand, along with default tracing level from the class's constructor we can use them to instrument all the methods in the class, `traceMethods` handles that (4)
- Now we produce the list of definitions as the output of the macro
- If we created a new `Tracer` we want to add its definition to the output, along with the new definitions of the instrumented methods[^forget] (5)
- With the new class body, we create a new class definition, reusing the original class's symbol (6)
- We return the redefined class as the output of the macro (7)
- Fail to compile on any definition that's not a class (8)

[^forget]: Note that if we forget to add the newly created symbol to the class, it will still compile, but will fail at runtime with a `NoSuchMethodError`, as the symbol will be missing then. Scary stuff.

That's it, we can use this magical annotation now. We exercise the macro annotation with different combinations of methods and classes.

```scala wrap=false
// 1
@traceClass(TraceLevel.Info)
class ClassAnnotationUsage:
  // 2
  given Tracer = Tracer.make[ClassAnnotationUsage]
 

  // 3
  @traceAt(TraceLevel.Debug)
  def theMethodToBeTraced1(arg1: String,
                           arg2: Int,
                           arg3: SomeData,
                           arg4: UntraceableData): String =
    if arg2 > 2 then "hello"
    else "bye"

  // 4
  def theMethodToBeTraced2(arg1: String,
                           arg2: Int,
                           arg3: SomeData,
                           arg4: UntraceableData)
                          (using Tracer): String =
    if arg2 > 2 then "hello"
    else "bye"

// 5
@traceClass(TraceLevel.Info)
trait TraitAnnotationUsage:
  // 6

  // 7
  def theMethodToBeTraced1(arg1: String,
                           arg2: Int,
                           arg3: SomeData,
                           arg4: UntraceableData): String =
    if arg2 > 2 then "hello"
    else "bye"

  // 8
  def methodNotTraced(arg1: String, arg2: Int): Boolean
```

- First a regular class with the `Info` default (1)
- In (2) we provide our own `given` `Tracer` and it will be used as the fallback when tracing methods that don't have their own tracer in scope
- The fallback tracer should be used in (3), at the non-default `Debug` level
- The `given` argument `Tracer` should be used in (4), with the fallback tracing level
- We apply the macro to a trait (5), so we should skip any abstract methods and not instrument them
- There's no given tracer in (6), so one should be generated as a member and used as fallback
- The method in (7) should trace with the generated fallback tracer at the default level
- The method in (8) should not be instrumented in any way since it's abstract

All of these lofty promises are fulfilled in the (very lengthy) generated code.


<details>
<summary>Click here to see the generated code</summary>

```scala wrap=false
@traceClass( TraceLevel.Info) class ClassAnnotationUsage extends Object()
      {
     final lazy given val given_Tracer: Tracer =
       Tracer.make[ClassAnnotationUsage](
         scala.reflect.ClassTag.apply[ClassAnnotationUsage](
           classOf[ClassAnnotationUsage])
       )
     @traceAt(TraceLevel.Debug) def theMethodToBeTraced1(
       arg1: String, arg2: Int, arg3: SomeData,
       arg4: UntraceableData): String =
       (if this.given_Tracer.isLevelEnabled(TraceLevel.Debug) then // <--- 1
 
         {
           this.given_Tracer.start(TraceLevel.Debug,
             "theMethodToBeTraced1",
             [
               ArrowAssoc[String]("arg1").->[String](
                 ToTrace.given_ToTrace_String.toTraceString(arg1))
                 ,
               ArrowAssoc[String]("arg2").->[String](
                 ToTrace.given_ToTrace_Int.toTraceString(arg2)),
               ArrowAssoc[String]("arg3").->[String](
                 SomeData.given_ToTrace_SomeData.toTraceString(
                   arg3)
               )
              : (String, String)]**
           )
           try 
             {
               val result: ("hello" : String) | ("bye" : String) =
                 if arg2.>(2) then "hello" else "bye"
               this.given_Tracer.finish(TraceLevel.Debug,
                 "theMethodToBeTraced1",
                 [ArrowAssoc[String]("result").->[String](result.toString()) :
                   (String, String)]*
               )
               result:("hello" : String) | ("bye" : String)
             }
            catch 
             {
               case scala.util.control.NonFatal(e @ _) =>
                 this.given_Tracer.finish(TraceLevel.Debug,
                   "theMethodToBeTraced1",
                   [ArrowAssoc[String]("exception").->[String](e.toString()) :
                     (String, String)]*
                 )
                 throw e
             }
         }
        else if arg2.>(2) then "hello" else "bye"):
         ("hello" : String) | ("bye" : String):
         ("hello" : String) | ("bye" : String)
     def theMethodToBeTraced2(arg1: String, arg2: Int, arg3: SomeData, arg4: UntraceableData)(using x$5: Tracer): String =
       (if x$5.isLevelEnabled(TraceLevel.Info) then  // <--- 2
         {
           x$5.start(TraceLevel.Info, "theMethodToBeTraced2",
             [
               ArrowAssoc[String]("arg1").->[String](
                 ToTrace.given_ToTrace_String.toTraceString(arg1))
                 ,
               ArrowAssoc[String]("arg2").->[String](
                 ToTrace.given_ToTrace_Int.toTraceString(arg2)),
               ArrowAssoc[String]("arg3").->[String](
                 SomeData.given_ToTrace_SomeData.toTraceString(
                   arg3)
               )
              : (String, String)]**
           )
           try 
             {
               val result: ("hello" : String) | ("bye" : String) =
                 if arg2.>(2) then "hello" else "bye"
               x$5.finish(TraceLevel.Info,
                 "theMethodToBeTraced2",
                 [ArrowAssoc[String]("result").->[String](result.toString()) :
                   (String, String)]*
               )
               result:("hello" : String) | ("bye" : String)
             }
            catch 
             {
               case scala.util.control.NonFatal(e @ _) =>
                 x$5.finish(TraceLevel.Info,
                   "theMethodToBeTraced2",
                   [ArrowAssoc[String]("exception").->[String](e.toString()) :
                     (String, String)]*
                 )
                 throw e
             }
         }
        else if arg2.>(2) then "hello" else "bye"):
         ("hello" : String) | ("bye" : String):
         ("hello" : String) | ("bye" : String)
   }
     @traceClass(TraceLevel.Info) trait TraitAnnotationUsage extends Object {
     private final lazy val tracer$macro$1: Tracer =  // <--- 3
       Tracer.make[TraitAnnotationUsage](
         scala.reflect.ClassTag.apply[TraitAnnotationUsage](
           classOf[TraitAnnotationUsage])
       )
     def theMethodToBeTraced1(arg1: String, arg2: Int, arg3: SomeData, arg4: UntraceableData):
       String =
       (if this.tracer$macro$1.isLevelEnabled(TraceLevel.Info) // <--- 4
          then
         {
           this.tracer$macro$1.start(TraceLevel.Info,
             "theMethodToBeTraced1",
             [
               ArrowAssoc[String]("arg1").->[String](
                 ToTrace.given_ToTrace_String.toTraceString(arg1))
                 ,
               ArrowAssoc[String]("arg2").->[String](
                 ToTrace.given_ToTrace_Int.toTraceString(arg2)),
               ArrowAssoc[String]("arg3").->[String](
                 SomeData.given_ToTrace_SomeData.toTraceString(
                   arg3)
               )
              : (String, String)]**
           )
           try 
             {
               val result: ("hello" : String) | ("bye" : String) =
                 if arg2.>(2) then "hello" else "bye"
               this.tracer$macro$1.finish(TraceLevel.Info,
                 "theMethodToBeTraced1",
                 [ArrowAssoc[String]("result").->[String](result.toString()) :
                   (String, String)]*
               )
               result:("hello" : String) | ("bye" : String)
             }
            catch 
             {
               case scala.util.control.NonFatal(e @ _) =>
                 this.tracer$macro$1.finish(TraceLevel.Info,
                   "theMethodToBeTraced1",
                   [ArrowAssoc[String]("exception").->[String](e.toString()) :
                     (String, String)]*
                 )
                 throw e
             }
         }
        else if arg2.>(2) then "hello" else "bye"):
         ("hello" : String) | ("bye" : String):
         ("hello" : String) | ("bye" : String)
     def methodNotTraced(arg1: String, arg2: Int): Boolean // <--- 5 
   }
```

As promised:
- In (1) we override the default tracing to debug
- We use the default level in (2)
- A default tracer is generated for the trait in (3)
- The default tracer is used in (4)
- The abstract method in (5) is not modified in any way

</details>

We can see how instrumentation works in this runnable `main`, respecting all the different combinations we defined above:

```scala wrap=false
object ClassAnnotationUsage:
  @main def classAnnotation() =
    val usage1 = new ClassAnnotationUsage

    // 1
    usage1.theMethodToBeTraced1("abc", 123, SomeData(4, "password"), UntraceableData('d', "efg"))

    locally:
      trait OtherTracer // 2
      given Tracer = Tracer.make[OtherTracer]

      // 3
      usage1.theMethodToBeTraced2("abc", 123, SomeData(4, "password"), UntraceableData('d', "efg"))

    val usage2 = new TraitAnnotationUsage: // 4
      def methodNotTraced(arg1: String, arg2: Int): Boolean = false

    // 5
    usage2.theMethodToBeTraced1("abc", 123, SomeData(4, "password"), UntraceableData('d', "efg"))
```

- (1) should use the default tracer, at the `Debug` tracing level
- We create another marker in the tracing message to distinguish that we are using the correctly scoped tracer (2)
- (3) should use `OtherTracer` at the (default) `Info` level
- We create an instance of our trait with an implementation of the abstract method (4)
- (5) should use the generated tracer for the trait at the `Info` level

And here's the output of running this code, behaving exactly as specified, using the correct tracers and levels:
```txt wrap=false
[debug][ClassAnnotationUsage]: *start* theMethodToBeTraced1 arg1: abc, arg2: 123, arg3: SomeData(4, <redacted>)
[debug][ClassAnnotationUsage]: *finish* theMethodToBeTraced1 result: hello
[info][OtherTracer]: *start* theMethodToBeTraced2 arg1: abc, arg2: 123, arg3: SomeData(4, <redacted>)
[info][OtherTracer]: *finish* theMethodToBeTraced2 result: hello
[info][TraitAnnotationUsage]: *start* theMethodToBeTraced1 arg1: abc, arg2: 123, arg3: SomeData(4, <redacted>)
[info][TraitAnnotationUsage]: *finish* theMethodToBeTraced1 result: hello
```

We finally reached a fully-automated tracing heaven... Every aspect of the original boilerplate is handled by the `traceClass` annotation macro.

## Conclusion

And there you have it. We've seen how macros can solve problems at varying levels of difficulty and sophistication. Although not without some rough edges, macros rose up to all the tasks we've thrown at them. I hope that this example was realistic enough to inspire you to solve problems in your own code using macros.

Happy macroing!

---
