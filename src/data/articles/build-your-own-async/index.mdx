---
title: "Build your own async"
excerpt: "This article provides some information on how to build your own async in Scala"
category: guide
tags: [async, continuations, graalvm, scala, scala-3]
publishedDate: 2025-10-23
updatedDate: 2025-10-23
author: chia-hung-lin
repositoryUrl: https://codeberg.org/chlin501/async4s
---

## Introduction

When writing programmes with the aid of async/ await pattern code, have you ever wondered how [async](https://en.wikipedia.org/wiki/Asynchronous_I/O) works under the hood? I have a similar question. Here we are going to explore an apporach alternative to monadic operations style employeed by libraries such as ZIO, cats-effect.

## Concepts

Before starting, two concepts are important, including

1. [Coroutine](#coroutine)

2. [Event Loop](#event-loop)

### Coroutine

[Coroutine](https://en.wikipedia.org/wiki/Coroutine), according to the Wikipedia, allows an execution to be suspended, and resumed from where it was left off. From the code snippet below, we can observe that the coroutine **Gen** *yield*s values at the line 3rd, 5th, and 7th, and the main thread notifies the coroutine by *send* method at the line 17th.

```scala
  1: class Gen extends Coroutine[String, Int] {
  2:   override def generate(): Unit = {
  3:     val received1 = `yield`(1)
  4:     println(s"Message sent from the caller: ${received1}")
  5:     val received2 = `yield`(2)
  6:     println(s"Message sent from the caller: ${received2}")
  7:     val received3 = `yield`(3)
  8:     println(s"Message sent from the caller: ${received3}")
  9:   }
 10: }
 11:
 12: @main def run(): Unit =  {
 13:   val gen = new Gen()
 14:   while (gen.hasMoreElements()) {
 15:     val yielded = gen.nextElement()
 16:     println("Caller receives a value: ${yielded}")
 17:     gen.send(s"Caller sends str ${yielded}")
 18:   }
 19: }
```

Thus, it can be viewed as a generalized subroutine in favor of [cooperative multitasking](https://en.wikipedia.org/wiki/Cooperative_multitasking). A higher level workflow between coroutine(s), and the main thread can be roughly sketeched with the following image.

![Coroutine cooperates with the main thread](images/cooperative-multitasking.png "cooperative multitasking")

### Event loop

Beside the component coroutine, the entire system needs a way to manage the execution of coruotines submitted. A simplest setup is create an event loop that picks up a coroutine from its backlog, and execute that coroutine until the coroutine suspends, or completes. The control flow is then returned to the event loop, which picks up the next coroutine to run, repeating the same operation, until no more pending tasks. The pseudocode could be something like this:

```pseudocode
SET all coroutines TO event loop's backlog somewhere in the system
WHILE event loop's backlog size > 0 DO
  GET a coroutine from event loop's backlog
  EXECUTE the coroutine
  IF running == coroutine state THEN
    PUT the coroutine back to the event loop's backlog
  ELSE IF done == coroutine state THEN
    PASS
  END IF
```

Scala code snippet from this project with some detail omitted can be refferred to as below. First, the programme **fetche**s a task, i.e.coroutine, from its corresponded task queue at the line 5th; second, the programme **execute**s that task at the line 6th; third, the programme **check**s the task's state, and act accordingly at the line 7th to 13th - if the task is in **ready** or **running** state, the programme place the task back to the task queue, continouing the programme by **fetch**ing the next task to run; whereas if the task **accomplish**es its execution, the programme repeats the same flow by fetching the next task to run, or the programme **exit**s when no more tasks in the task queue.

```scala
  1:  def consume(taskQueue: TaskQueue[Task[_, _]]): Any = {
  2:    @tailrec
  3:    def fnWhile(fetchTask: => Task[_, _]...): Any = {
  4:
  5:      val (newTask, ...) = fetchTask
  6:      val (_, newTask1) = execute(newTask)
  7:      newTask1.state() match {
  8:        case State.Ready | State.Running =>
  9:          val (_, ...) = newTaskQueue.add(newTask1)
 10:          fnWhile(newTaskQueue1.fetch())
 11:        case State.Stopped =>
 12:          if (0 != newTaskQueue.size()) fnWhile(newTaskQueue.fetch()) else ()
 13:      }
 14:    }
 15:    fnWhile(taskQueue.fetch())
 16:  }
 17:  scheduler.taskQueues.foreach { taskQueue =>
 18:    val callable = new Callable[Any] {
 19:      @throws(classOf[RuntimeException])
 20:      override def call(): Any = consume(taskQueue)
 21:    }
 22:    executors.submit(callable)
 23:  }
 ```

## Prerequisite

:::caution

The code in the repository merely tests against a specific version of Scala and GraalVM specified in this section. Other versions may or may not be working as expected. Also, at the writeup, build tools such as sbt, maven, and gradle did not work, so some manual operations are necessary.

:::

In order to achieve our goal, following two softwares are required to install before proceeding to the next step - one is GraalVM, the other Scala.

- [GraalVM Espresso: 24.2 standalone](https://www.graalvm.org/latest/reference-manual/espresso)

- Scala 3.3.6

GraalVM provides [Continuation API](https://www.graalvm.org/jdk25/reference-manual/espresso/continuations/), based on [Truffleo framework](https://www.graalvm.org/22.2/graalvm-as-a-platform/language-implementation-framework/), allowing the programme to suspend, resume, and serialize to external storages.

### Structure Layout

The layout of the folder structure actually is the same as that of conventional build tools employeed by sbt, maven, and so on.

```bash
.
├── async
│   └── src
│       └── main
│           └── scala
│               └── async
│                   └── ... scala files ...
├── continuations
│   └── src
│       └── main
│           └── scala
│               └── continuations
│                   └── Coroutine.scala
└── Makefile
```

### Dependencies

Required dependencies for this project include scala-xml_2.13-1.2.0, scala-library_2.13.16, scala3-library_3-3.3.6, scala3-library_sjs1_3-3.7.2, continuations-24.2.2.

The installation of these jar files can be reffered to at the Makefile [install-async-libraries](https://codeberg.org/chlin501/async4s/src/branch/main/Makefile#L15) target, and [install-continuations-libraries](https://codeberg.org/chlin501/async4s/src/branch/main/Makefile#L33) target. Otherwise, please use the curl command to install dependencies manully.

```bash
curl -s -L -O --create-dirs --output-dir $(async lib dir) "https://{maven repo website}/.../{scala or continuations}.jar"
```

## Higher Overview

The diagram below sketeches a higher overview relationship between the components this project is going to use.

* *Task* is the model upon which all other components operate

* *Worker* serves as a proxy sitting between *[Scheduler](#scheduler)* and *[Task Queue](#task-queue)

* *Task Queue* stores *[task](#task)s* to be executed

* *Scheduler*'s responsibility is schedule *[task](#task)*

* *Runtime* assembles all components together, hosting an environemt for necessary operations

![Async Class Diagram](images/class-diagram.png "Async Class Diagram")

## Components

Primarily, this programme requires following components to work, including [Task](#task), [Worker](#worker), [Task Queue](#task-queue), [Scheduler](#scheduler), and [Runtime](#runtime).

### Task

#### Coroutine

Although GraalVM provdes Continuation API, the API itself does not contain any Coroutine classes. Fortunately, this API offers *[Generator](https://www.graalvm.org/latest/reference-manual/espresso/continuations/generators/)* class, that serves several critical methods - `generate()`, `emit()`, `hasMoreElements()`, and `nextElement()`. The first methods is a place where a developer fills in their programme's primary logic, inside which the code can execute `emit()` providing a value to the caller if needed, and then suspend the programme execution, whilst the developer can exploit the last two methods checking if the Generator object offers more values to emit at the caller side.

Therefore, the frist thing is to create our own Coroutine.

```scala
  1: abstract class Coroutine[S, E] extends Generator[E] {
  2:   var value: Option[S] = None
  3:   def send(value: Option[S]): Unit = this.value = value
  4:   def send(value: S): Unit = send(Option(value))
  5:   def `yield`(element: E): Option[S] = {
  6:     emit(element)
  7:     value
  8:   }
  9: }
```

In fact, *Task* component is merely a wrapper of Coroutine mentioned above, plus self defined [State](https://codeberg.org/chlin501/async4s/src/branch/main/async/src/main/scala/async/Task.scala#L20)s

```scala
  1: enum State {
  2:   case Ready, Stopped, Running
  3: }
```

so that the system can determine whether to emit (at the line 5th, and 11th below), send (at the line 9th) values during execution.

```scala
  1: override def execute(value: Option[S] = None): (Option[E], Task[S, E]) =
  2:   internalState match {
  3:     case State.Ready =>
  4:       if (coroutine.hasMoreElements())
  5:         (Option(coroutine.nextElement()), copy(internalState = State.Running))
  6:       else
  7:         (None, copy(internalState = State.Running))
  8:     case State.Running =>
  9:       value.foreach(coroutine.send(_))
 10:       if (coroutine.hasMoreElements())
 11:         (Option(coroutine.nextElement()), copy(internalState = State.Running))
 12:       else {
 13:         signal.foreach(_.offer(Stopped(name)))
 14:         (None, copy(internalState = State.Stopped))
 15:       }
 16:     case State.Stopped => (None, this)
 18:   }
```


### Worker

### Task Queue

### Scheduler

#### Least-Loaded (LL) Scheduler

This project exploits least loaded scheduling logic, which schedules task to a least loaded worker. The primary reason comes from that the scheduling logic employeed by, e.g., Rust's Tokio work-stealing scheduler is very complicated[1]. Least-Loaded scheduling logic is simple yet effective strategy.

### Runtime

## Conclusions

## References

[1]. [Least-Loaded (LL) Scheduler](https://nurmohammed840.github.io/posts/announcing-nio/#least-loaded-ll-scheduler)
[1]. [Announcing Nio](https://nurmohammed840.github.io/posts/announcing-nio/)
